---
layout: post
title: "[UE5] MVVM (Model Veiw VeiwModel) 이론"
description: MVVM 이론과 사용하는 이유에 대해서 설명
date: 2025-12-30 09:00:00 +0900
categories: [Unreal Engine, Analysis]
tags: [Unreal Engine, MVVM, Model Veiw VeiwModel]
---
## UI 아키텍처에 대하여

UMG는 빠르게 화면을 만들기 좋습니다. 문제는 프로젝트가 커질수록, 작업자가 늘어날수록 UI 하나에 대해서 작업이 병목되는 순간이 온다는 점입니다. UI 디자이너가 UMG를 수정하는 동안, 프로그래머는 해당 UMG 블루프린트를 수정할 수 없고, 반대의 경우도 마찬가지였죠. 결국 <u>서로가 같은 리소스를 붙잡는 동안, 한 사람은 일을 멈추고 기다려야 하고, 이는 생산성도 떨어지는 작업 구조</u>가 되어 버립니다.

이런 협업 이슈도 있지만, 구조적인 문제 또한 있습니다. 언리얼에서는 보통 <u>하나의 UMG 안에 <b>"화면 표현, 입력 처리, 간단한 상태 저장 및 데이터 조작"</b> 이 전부 섞여 있기 때문에 UMG가 너무 많은 책임을 가지게 되고, 시스템이 커짐에 따라 유지보수가 점점 힘들어지는 구조</u>가 되버렸죠.

이러한 이유 때문에 기존 UI 아키텍처를 개선하고 싶었고, MVVM에 대해 알게되었습니다.

<br>

## 전통적인 UI 디자인 패턴들

![Design Pattern](/assets/img/post/MVVM/DesignPattern.png){: width="80%" style="display:block; margin: 0 auto;"}
*Design Pattern*

UI 쪽에서 자주 언급되는 패턴들은 보통 세 가지입니다. 이미 자료가 많기 때문에, 여기서는 MVVM과 비교하는 데 핵심 부분만 짧게 짚고 넘어가겠습니다. 쉽게 말하면, MVC와 MVP는 접근 가능 여부에 따른 차이가 크고, MVVM은 데이터 상태가 바뀌면 전달하는 반응형입니다.

<br>

### MVC

- Model, View, Controller 세 가지로 역할을 나뉘며, 서로 참조 가능한 구조
- 빠르게 만들기 좋지만, 규모가 커질수록 의존성이 꼬이기 쉬움

---

### MVP

- View와 Model은 서로를 모르고, Presenter가 중간에서 모든 걸 중재
- View는 Presenter에게 입력을 전달하고, Presenter는 Model을 갱신한 뒤, 다시 View를 갱신
- View를 가볍게 유지할 수 있지만, View와 Presenter가 1:1 대응이기에 의존성이 높음

---

### MVVM

- 기본적으로 직접 참조는 없고, 데이터 바인딩을 기본으로 진행하며, 반응형 흐름으로 처리
- View는 직접 Model을 만지지 않고, **ViewModel**을 통해 데이터 수신
- ViewModel은 Model을 알고, View는 ViewModel을 알지만, Model은 둘 다 모르는 구조

<br>

## 언리얼 UMG 구조를 패턴 관점에서 보기

| 요소 | 설명 | 디자인 패턴 |
| --- | --- | --- |
| **UMG** | 버튼, 텍스트 등 위젯 구성과 로직 처리 | View + Controller |
| **이벤트 바인딩** | 위젯 함수에 이벤트 바인딩 | ViewModel |
| **GameState / PlayerState** | 게임 진행 상태, 플레이어 정보, 점수 등 저장 | Model |

언리얼에서 별도의 MVVM 플러그인 없이, 일반적인 UMG만 사용한다면 대략적인 역할은 위 표와 같습니다.  즉, `UserWidget`이 화면 표현, 입력 처리데이터 접근까지 모두 관리하는 구조이죠. 

그래서 억지로 패턴에 끼워 맞춰보면, 위 표와 비슷하다고 볼 수 있지만, 솔직히 "언리얼의 위젯 아키텍처는 MVC"라고 말하기에는 역할이 꽤 섞여 있는 구조입니다. 확실한건 UMG가 중심이 되는 구조이죠. 이 시스템을 따라가게 되면 어떤 문제가 있을까요?

<br>

## 다양한 문제들

### 1. Widget의 과도한 책임

`UMG`는 보통 "시각적인 표현, 버튼과 같은 입력 처리, 데이터 접근" 등 다양한 것들을 처리하고는 합니다. 처음에 사용은 편리하지만, 시각적인 표현만 담당하는 위젯의 복잡도가 올라가고, UI에서 GamePlay 객체를 직접 잡고 로직을 호출하거나, 반대로 참조하는 등 의존성이 꼬이게 됩니다. 

즉, **UI는 표현만 하는게 아닌, 로직의 주체가 되어버립니다.**

---

### 2. Widget과 로직의 양방향 의존

UMG는 구조적으로 로직을 알고, 로직도 UMG를 알아버리는 양방향 의존이 강합니다. 바로 접근하면 편리하기는 하지만 프로젝트가 커질수록 상호의존이 강해지게 되어 UI 없이는 기능 테스트가 어렵고, UI의 변경이 곧 로직 변경 리스크로 다가옵니다.

---

### 3. 병렬 작업의 불가능

디자이너는 `UMG`안에서 레이아웃과 애니메이션을 수정해야 하고, 프로그래머는 같은 파일에서 로직을 수정해야 합니다. 하지만 둘 다 **하나의 위젯 파일**에 매달려 있기 때문에, 동시에 안정적으로 작업하기 어렵습니다. 

<br>

## MVVM 도입의 이유

| 역할 | 주체 | 설명 |
| --- | --- | --- |
| **View** | UUserWidget (UMG) | 화면 표현, 사용자 입력 이벤트 발생 지점 |
| **ViewModel** | MVVM ViewModel 객체 | View에서 바인딩 가능한 함수 제공, UI용 데이터 가공 |
| **Model** | GameState, PlayerState 등… | 실제 게임 상태와 규칙을 담는 오브젝트 |

제가 MVVM을 공부하고 도입하고자 했던 것은 이전과 같은 문제점들을 해결하기 위해서였습니다. 아래는 MVVM을 사용해서 얻고자 하는 목표에용.

1. `UUserWidget`은 로직이 아닌, 시각적인 **표현** 에 집중시키기
2. ViewModel을 통해 **데이터 기반, 단방향 흐름**을 만들기
3. UI 디자이너와 프로그래머가 **서로 다른 레이어**에서 병렬로 작업할 수 있게 만들기

<br>

이는 MVVM을 이용하면 대부분 해결이 가능합니다. UMG는 데이터를 직접 바꾸지 않고, ViewModel에서 전달한 데이터를 기반으로 View의 역할만 진행합니다. 그렇기 때문에 UMG가 없어도 Model은 무관하게 동작할 수 있죠. 

> 연출 작업은 필요하기 때문에 3번 목표는 완벽하게 해결할 수 없지만, UMG에서 작업하는 프로그래머의 작업량이 크게 줄어듭니다.
{: .prompt-warning }

<br>

## 마무리

이번 글에서는 언리얼 엔진의 기본 UMG 구조를 분석해서 문제점들을 찾고, 그에 대한 개선안으로 MVVM 패턴을 응용했을 때, 어떤 강점들이 있는지에 대해서 정리해봤습니다. 

다음 글에서는 실제로 언리얼 엔진의 MVVM 플러그인을 기준으로, 간단한 사용 방법, 제가 설계하는 방식이나 팁들에 대해서 구체적인 예시와 함께 정리해보겠습니다.

<br>

## 참조 자료

- [[공식 문서] UMG 뷰 모델](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/umg-viewmodel-for-unreal-engine)
- [Model View ViewModel For Game Devs](https://miltoncandelero.github.io/unreal-viewmodel)
